#! /usr/bin/python

import time
import random
import logging
import sys
import os
from optparse import OptionParser

import tp.client.threads
from tp.netlib.client import url2bits
from tp.netlib import Connection
from tp.netlib import failed, constants, objects
from tp.client.cache import Cache

from rulesystem import RuleSystem,BoundConstraint

version = (0, 0, 1)
mods = []

installpath = os.path.realpath(os.path.dirname(__file__))

def callback(*args, **kw):
    #print args, kw
    pass

def connect(uri='tp://daneel-ai:cannonfodder@localhost/tp'):
    debug = False

    host, username, game, password = url2bits(uri)
    if not game is None:
        username = "%s@%s" % (username, game)

    connection = Connection()

    # Download the entire universe
    if connection.setup(host=host, debug=debug):
        print "Unable to connect to the host."
        return

    if failed(connection.connect("daneel-ai/%i.%i.%i" % version)):
        print "Unable to connect to the host."
        return

    if failed(connection.login(username, password)):
        # Try creating the user..
        print "User did not exist, trying to create user."
        if failed(connection.account(username, password, "", "daneel-ai bot")):
            print "Username / Password incorrect."
            return

        if failed(connection.login(username, password)):
            print "Created username, but still couldn't login :/"
            return

    cache = Cache(Cache.key(host, username))
    return connection, cache

def createRuleSystem(rulesfile,verbosity,cache,connection):
    global mods
    cons,rules = [],[]
    funcs = {}
    rf = open(os.path.join(installpath, 'rules', rulesfile))
    l = stripline(rf.readline())
    while l != "[Modules]":
        l = stripline(rf.readline())
    l = stripline(rf.readline())
    while l != "[Constraints]":
        if l != "":
            m = __import__(l)
            mods.append(m)
            try:
                cons.extend(m.constraints)
            except AttributeError:
                pass
            try:
                rules.extend(m.rules)
            except AttributeError:
                pass
            try:
                exec("".join(m.functions),funcs)
            except AttributeError:
                pass
        l = stripline(rf.readline())
    l = stripline(rf.readline())
    while l != "[Rules]":
        if l != "": cons.append(l)
        l = stripline(rf.readline())
    l = stripline(rf.readline())
    while l != "[Functions]":
        if l != "": rules.append(l)
        l = stripline(rf.readline())
    exec("".join(rf.readlines()),funcs)
    funcs['cache'] = cache
    funcs['connection'] = connection

    return RuleSystem(cons,rules,funcs,verbosity)

def stripline(line):
    if line[0] == "#": return ""
    return line.strip()

def startTurn(cache,store):
    for m in mods:
        try:
            m.startTurn(cache,store)
        except AttributeError:
            pass

def endTurn(cache,rulesystem,connection):
    for m in mods:
        try:
            m.endTurn(cache,rulesystem,connection)
        except AttributeError:
            pass

def init(cache,rulesystem,connection):
    for m in mods:
        try:
            m.init(cache,rulesystem,connection)
        except AttributeError:
            pass

def gameLoop(rulesfile,turns=-1,uri='tp://daneel-ai:cannonfodder@localhost/tp',verbosity=0):
    try:
        level = {0:logging.WARNING,1:logging.INFO,2:logging.DEBUG}[verbosity]
    except KeyError:
        level = 1
    fmt = "%(asctime)s [%(levelname)s] %(name)s:%(message)s"
    logging.basicConfig(level=level,stream=sys.stdout,format=fmt)
    connection, cache = connect(uri)
    rulesystem = createRuleSystem(rulesfile,verbosity,cache,connection)
    logging.getLogger("daneel").info("Downloading all data")
    cache.update(connection,callback)
    init(cache,rulesystem,connection)
    while turns != 0:
        turns = turns - 1
        logging.getLogger("daneel").info("Downloading updates")
        cache.update(connection,callback)

        startTurn(cache,rulesystem)
        rulesystem.addConstraint("cacheentered")
        endTurn(cache,rulesystem,connection)

        rulesystem.clearStore()
        connection.turnfinished()
        waitfor = connection.time()
        logging.getLogger("daneel").info("Awaiting end of turn (%d s)..." % waitfor)
        while waitfor > 1:
            time.sleep(1)
            waitfor = connection.time()
        time.sleep(2)

if __name__ == "__main__":
    parser = OptionParser(version="%prog " + ("%i.%i.%i" % version))
    parser.add_option("-f", "--file", dest="filename", default="rfts",
                      help="read rules from FILENAME [default: %default]")
    parser.add_option("-n", "--numturns", dest="numturns", type="int", default=-1,
                      help="run for NUMTURNS turns [default: unlimited]")
    parser.add_option("-u", "--uri", dest="uri",
                      default='tp://daneel-ai:cannonfodder@localhost/tp',
                      help="Connect to specified URI [default %default]")
    parser.add_option("-v", action="count", dest="verbosity", default=0,
                      help="More verbose output. -vv and -vvv increase output even more.")


    (options, args) = parser.parse_args()
    gameLoop(options.filename,turns=options.numturns,uri=options.uri,verbosity=options.verbosity)
